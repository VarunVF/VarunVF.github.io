[["index.html", "VarunVF’s Projects Hello World", " VarunVF’s Projects VarunVF 2024-06-23 Hello World This is a simple website to showcase my projects. "],["jlox.html", "Chapter 1 jlox 1.1 Motivation 1.2 Language Features", " Chapter 1 jlox jlox is my implementation of the Lox programming language, written in Java. It uses the tree-walk interpreter from the Crafting Interpreters book. My jlox is currently still a work in progress. 1.1 Motivation Over time, programming languages have become more and more abstract. As such, the code we write has gotten closer and closer to spoken language. This is a trend that I believe will only continue in future years, especially with the development of Artificial Intelligence (AI) that is able to process inputs as high-level as natural language. Even the practice of designing and refining the prompts provided to LLMs is somewhat akin to programming (prompt engineering). It can be easy to take for granted the amount of work that high-level programming languages perform for us behind the scenes. Wanting to know more about how they really work, I took an interest in language interpreters and compilers. 1.2 Language Features 1.2.1 Data Types Lox features several built-in data types. 1.2.1.1 Booleans true; false; 1.2.1.2 Numbers Lox uses only floating-point numbers. wholeNumber = 34; // 34.0 fractionalNumber = 12.5; // 12.5 1.2.1.3 Strings &quot;Hello, world!&quot;; &quot;&quot;; // An empty string. 1.2.1.4 nil nil represents no value, similar to null in other languages. It shows up in several places such as void functions and uninitialised variables. 1.2.2 Expressions 1.2.2.1 Mathematical Expressions jlox features common numeric operations and negation: a + b - a; a * b / c; -value; 1.2.2.2 Comparisons Numbers can be compared with the usual comparison operators &lt; &gt; &lt;= &gt;=: 1 &lt;= 2; // true We can test for equality or inequality with == and !=: 1 == 1; // true &quot;foo&quot; != &quot;bar&quot;; // true &quot;42&quot; == 42; // false Different types are never equivalent. 1.2.2.3 Logical Expressions !true; // false true or false; // true true and false; // false 1.2.2.4 Variables Declare variables with var: var message = &quot;Hello&quot;; var uninitialisedVariable; // set to nil 1.2.3 Control Flow if and else statements: if (condition) { // ... } else { // ... } while and for loops: while (num &gt; 0) { num = num - 1; } for (var i = 0; i &lt; 5; i = i + 1) { print i; } 1.2.4 Functions Functions are first class in Lox, and return nil by default. fun sum(first, second) { return first + second; } sum(1, 2); 1.2.5 Classes Class methods are declared without the fun keyword. class Entity { move() { print &quot;Entity moved!&quot;; } } var myEntity = Entity(); // Created instance of Entity class We can assign fields, or create them if they don’t already exist: myEntity.age = 57; myEntity.name = &quot;Bob&quot;; We can also do this in the init method which is called when the object is constructed: class Entity { init(age, name) { this.age = age; this.name = name; } // ... } var myEntity = Entity(57, &quot;Bob&quot;); The arguments passed to the class are forwarded to the init method. 1.2.5.1 Inheritance Lox supports single inheritance using the &lt; operator. class Alien &lt; Entity { init(age, name, planet) { super.init(age, name); this.planet = planet; } } We can access methods of the superclass using super. 1.2.6 Comments jlox allows single-line comments with // or C-style block comments with /**/. "],["myOS.html", "Chapter 2 Operating Systems 2.1 Background Information 2.2 Assembly", " Chapter 2 Operating Systems myOS project description 2.1 Background Information 2.1.1 How a computer starts up The sequence is as follows: BIOS is copied from a ROM chip into RAM BIOS starts executing code initialises hardware runs some tests (POST = power on self test) BIOS searches for an OS to start BIOS loads and starts the OS OS runs 2.1.2 How the BIOS finds an OS (2 ways): LEGACY BOOTING BIOS loads first sector of each bootable device into memory (at location 0x7c00) BIOS checks for 0xaa55 signature (last two bytes of the first sector) If found, it starts executing code EFI BIOS looks for a special EFI partition which contains some special EFI programs OS must be compiled as an EFI programs We will use legacy booting for this OS. 2.1.3 Directives Used ORG directive: Tell the assembler where we expect our code to be loaded. Assembler uses this information to calculate label addresses. BITS directive: Tell the assembler to emit 16/32/64-bit code. TIMES [number] [instruction/data] directive: Repeats given instruction/data a number of times. $: Memory offset of the current line. $$: Memory offset of the beginning of the current section. 2.1.4 Memory Segmentation The segment and offset addressing scheme for memory can be used. It has the form segment:offset. For example, a memory address could be represented as 0x1234:0x5678 where 0x1234 is the segment and 0x5678 is the offset. In this scheme we address memory using two 16-bit values, the segment and the offset. Each segment contains 64kb of memory, where each byte can be accessed using the offset value. Segments overlap every 16 bytes. real_address = segment * 16 + offset This also means there are multiple ways to represent the same absolute memory address. In x86 architecture, there are special registers used to specify the actively used segments. CS - currently running code segment DS - data segment SS - stack segment ES, FS, GS - extra (data) segments In order to access data outside one of these active segments, we need to load that segment into one of these registers. The code segment can only be modified by performing a jump. Referencing a memory location: segment:[base + index * scale + displacement] segment: CS, DS, ES, FS, GS, SS if unspecified: SS when base register is BP DS otherwise base: (16 bits) BP/BX (32/64 bits) any general purpose register index: (16 bits) SI/DI scale: (32/64 bits only) 1, 2, 4, 8 displacement: a (signed) constant value Some limitations: Only BP and BX can be used as base registers Only SI and ID can be used as index registers Constants cannot be directly written to the segment registers. An intermediary register has to be used. Most operating systems will switch to 32- or 64-bit mode immediately after startup. 2.1.5 Bootloader and Kernel Bootloader: loads basic components into memory puts system in expected state collects information about system The bootloader will load the kernel. We will write the bootloader in the first sector of the disk, and the rest of the operating system (the kernel) will start from the second sector onwards. 2.2 Assembly org 0x7c00 ; We need to emit 16-bit code because the CPU always starts in 16-bit mode. bits 16 %define ENDL 0x0d, 0x0a start: jmp main ; ; Prints a string to the screen. ; Params: ; - ds:si points to string, ASCII, zero-delimited. ; puts: ; save registers we will modify push si push ax .loop: lodsb ; loads next char into al or al, al ; verify is next char is null jz .done mov ah, 0x0e ; Print Character in TTY Mode mov bh, 0 ; Page Number int 0x10 ; BIOS Interrupt: Video jmp .loop .done: pop ax pop si ret main: ; setup data segments mov ax, 0 ; can&#39;t write to ds/es directly mov ds, ax mov es, ax ; setup stack mov ss, ax mov sp, 0x7c00 ; stack grows downwards from beginning of program ; print message mov si, msg_hello call puts hlt .freeze: jmp .freeze msg_hello: db &quot;Hello, World!&quot;, ENDL, 0 ; $-$$: Length of the program so far in bytes. ; The BIOS expects the last two bytes of the first sector are 0xaa55. ; On a standard 1.44Mb floppy disk, each sector is 512b large. ; We pad the program up to 510 bytes and then declare the 2 bytes signature. times 510 - ($-$$) db 0 dw 0AA55h "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
